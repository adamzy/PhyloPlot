// Generated by CoffeeScript 1.8.0
(function() {
  var Node, Tree, equal_angle, root;

  Node = (function() {
    function Node() {
      this.name = "";
      this.children = [];
    }

    Node.prototype.addChild = function(child) {
      if (child == null) {
        child = new Node;
      }
      this.children.push(child);
      child.father = this;
      return child;
    };

    Node.prototype.isLeaf = function() {
      return this.children.length === 0;
    };

    Node.prototype.isRoot = function() {
      return (this.father == null) || (this.father === null);
    };

    Node.prototype.string = function() {
      var c, s;
      s = "" + this.name + (this.length != null ? ":" + this.length : "");
      if (this.children.length > 0) {
        return "(" + (((function() {
          var _i, _len, _ref, _results;
          _ref = this.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(c.string());
          }
          return _results;
        }).call(this)).join(",")) + ")" + s;
      } else {
        return s;
      }
    };

    Node.prototype.show = function() {
      return console.log("" + (this.string()) + ";");
    };

    Node.prototype.postToList = function(l) {
      var child, _i, _len, _ref;
      if (l == null) {
        l = [];
      }
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.postToList(l);
      }
      l.push(this);
      return l;
    };

    return Node;

  })();

  Tree = function(s) {
    var flag, item, node, token, tree, _i, _len, _ref, _ref1, _ref2;
    token = String(s).match(/[\(\),;:]|[^\(\),;:\s]+/g);
    if ((token == null) || token.length === 0) {
      throw "Invalid tree.";
    }
    tree = node = new Node;
    flag = false;
    for (_i = 0, _len = token.length; _i < _len; _i++) {
      item = token[_i];
      switch (item) {
        case "(":
          _ref = [node.addChild(), false], node = _ref[0], flag = _ref[1];
          break;
        case ")":
          if (node.father == null) {
            throw "Invalid Tree: " + s;
          }
          _ref1 = [node.father, false], node = _ref1[0], flag = _ref1[1];
          break;
        case ",":
          if (node.father == null) {
            throw "Invalid Tree: " + s;
          }
          _ref2 = [node.father.addChild(), false], node = _ref2[0], flag = _ref2[1];
          break;
        case ":":
          flag = true;
          break;
        case ";":
          break;
        default:
          if (flag) {
            if (isNaN(node.length = parseFloat(item))) {
              throw "Invalid branch length: " + item;
            }
          } else {
            node.name = item;
          }
          flag = false;
      }
    }
    if (tree !== node) {
      throw "Invalid Tree: " + s;
    }
    return tree;
  };

  equal_angle = function(tree_string, length_scale, equal_length) {
    var angle, c, i, length, move_along, n, postlist, present_langle, total_angle, tree, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2;
    tree = Tree(tree_string);
    postlist = tree.postToList();
    for (i = _i = 0, _len = postlist.length; _i < _len; i = ++_i) {
      n = postlist[i];
      if (n.isLeaf()) {
        n.numOfLeaves = 1;
      } else {
        n.numOfLeaves = 0;
        _ref = n.children;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          c = _ref[_j];
          n.numOfLeaves += c.numOfLeaves;
        }
      }
    }
    move_along = function(loc, direction, length) {
      var x, y;
      x = loc[0], y = loc[1];
      x += Math.cos(direction) * length;
      y += Math.sin(direction) * length;
      return [x, y];
    };
    tree.angle = [0, Math.PI];
    tree.loc = [0, 0];
    for (i = _k = _ref1 = postlist.length - 1; _ref1 <= 0 ? _k <= 0 : _k >= 0; i = _ref1 <= 0 ? ++_k : --_k) {
      n = postlist[i];
      total_angle = (n.angle[1] - n.angle[0]) * 2;
      present_langle = n.angle[0];
      _ref2 = n.children;
      for (_l = 0, _len2 = _ref2.length; _l < _len2; _l++) {
        c = _ref2[_l];
        angle = total_angle * c.numOfLeaves / n.numOfLeaves;
        c.angle = [present_langle, present_langle + angle / 2];
        if (equal_length) {
          length = length_scale;
        } else {
          length = c.length * length_scale;
        }
        c.loc = move_along(n.loc, c.angle[1], length);
        present_langle = present_langle + angle;
      }
    }
    return tree;
  };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.equal_angle = equal_angle;

}).call(this);
