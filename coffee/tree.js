<<<<<<< HEAD
// Generated by CoffeeScript 1.8.0
=======
// Generated by CoffeeScript 1.9.3
>>>>>>> master
(function() {
  var Node, Tree, equal_angle, root;

  Node = (function() {
    function Node() {
      this.name = "";
      this.children = [];
    }

    Node.prototype.addChild = function(child) {
      if (child == null) {
        child = new Node;
      }
      this.children.push(child);
      child.father = this;
      return child;
    };

    Node.prototype.isLeaf = function() {
      return this.children.length === 0;
    };

    Node.prototype.isRoot = function() {
      return (this.father == null) || (this.father === null);
    };

    Node.prototype.string = function() {
      var c, s;
      s = "" + this.name + (this.length != null ? ":" + this.length : "");
      if (this.children.length > 0) {
        return "(" + (((function() {
<<<<<<< HEAD
          var _i, _len, _ref, _results;
          _ref = this.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(c.string());
          }
          return _results;
=======
          var j, len, ref, results;
          ref = this.children;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            results.push(c.string());
          }
          return results;
>>>>>>> master
        }).call(this)).join(",")) + ")" + s;
      } else {
        return s;
      }
    };

    Node.prototype.show = function() {
<<<<<<< HEAD
      return console.log("" + (this.string()) + ";");
    };

    Node.prototype.postToList = function(l) {
      var child, _i, _len, _ref;
      if (l == null) {
        l = [];
      }
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
=======
      return console.log((this.string()) + ";");
    };

    Node.prototype.postToList = function(l) {
      var child, j, len, ref;
      if (l == null) {
        l = [];
      }
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
>>>>>>> master
        child.postToList(l);
      }
      l.push(this);
      return l;
    };

    return Node;

  })();

  Tree = function(s) {
<<<<<<< HEAD
    var flag, item, node, token, tree, _i, _len, _ref, _ref1, _ref2;
=======
    var flag, item, j, len, node, ref, ref1, ref2, token, tree;
>>>>>>> master
    token = String(s).match(/[\(\),;:]|[^\(\),;:\s]+/g);
    if ((token == null) || token.length === 0) {
      throw "Invalid tree.";
    }
    tree = node = new Node;
    flag = false;
<<<<<<< HEAD
    for (_i = 0, _len = token.length; _i < _len; _i++) {
      item = token[_i];
      switch (item) {
        case "(":
          _ref = [node.addChild(), false], node = _ref[0], flag = _ref[1];
=======
    for (j = 0, len = token.length; j < len; j++) {
      item = token[j];
      switch (item) {
        case "(":
          ref = [node.addChild(), false], node = ref[0], flag = ref[1];
>>>>>>> master
          break;
        case ")":
          if (node.father == null) {
            throw "Invalid Tree: " + s;
          }
<<<<<<< HEAD
          _ref1 = [node.father, false], node = _ref1[0], flag = _ref1[1];
=======
          ref1 = [node.father, false], node = ref1[0], flag = ref1[1];
>>>>>>> master
          break;
        case ",":
          if (node.father == null) {
            throw "Invalid Tree: " + s;
          }
<<<<<<< HEAD
          _ref2 = [node.father.addChild(), false], node = _ref2[0], flag = _ref2[1];
=======
          ref2 = [node.father.addChild(), false], node = ref2[0], flag = ref2[1];
>>>>>>> master
          break;
        case ":":
          flag = true;
          break;
        case ";":
          break;
        default:
          if (flag) {
            if (isNaN(node.length = parseFloat(item))) {
              throw "Invalid branch length: " + item;
            }
          } else {
            node.name = item;
          }
          flag = false;
      }
    }
    if (tree !== node) {
      throw "Invalid Tree: " + s;
    }
    return tree;
  };

  equal_angle = function(tree_string, length_scale, equal_length) {
<<<<<<< HEAD
    var angle, c, i, length, move_along, n, postlist, present_langle, total_angle, tree, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2;
    tree = Tree(tree_string);
    postlist = tree.postToList();
    for (i = _i = 0, _len = postlist.length; _i < _len; i = ++_i) {
=======
    var angle, c, i, j, k, len, len1, len2, length, m, move_along, n, o, postlist, present_langle, ref, ref1, ref2, total_angle, tree;
    tree = Tree(tree_string);
    postlist = tree.postToList();
    for (i = j = 0, len = postlist.length; j < len; i = ++j) {
>>>>>>> master
      n = postlist[i];
      if (n.isLeaf()) {
        n.numOfLeaves = 1;
      } else {
        n.numOfLeaves = 0;
<<<<<<< HEAD
        _ref = n.children;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          c = _ref[_j];
=======
        ref = n.children;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          c = ref[k];
>>>>>>> master
          n.numOfLeaves += c.numOfLeaves;
        }
      }
    }
    move_along = function(loc, direction, length) {
      var x, y;
      x = loc[0], y = loc[1];
      x += Math.cos(direction) * length;
      y += Math.sin(direction) * length;
      return [x, y];
    };
    tree.angle = [0, Math.PI];
    tree.loc = [0, 0];
<<<<<<< HEAD
    for (i = _k = _ref1 = postlist.length - 1; _ref1 <= 0 ? _k <= 0 : _k >= 0; i = _ref1 <= 0 ? ++_k : --_k) {
      n = postlist[i];
      total_angle = (n.angle[1] - n.angle[0]) * 2;
      present_langle = n.angle[0];
      _ref2 = n.children;
      for (_l = 0, _len2 = _ref2.length; _l < _len2; _l++) {
        c = _ref2[_l];
=======
    for (i = m = ref1 = postlist.length - 1; ref1 <= 0 ? m <= 0 : m >= 0; i = ref1 <= 0 ? ++m : --m) {
      n = postlist[i];
      total_angle = (n.angle[1] - n.angle[0]) * 2;
      present_langle = n.angle[0];
      ref2 = n.children;
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        c = ref2[o];
>>>>>>> master
        angle = total_angle * c.numOfLeaves / n.numOfLeaves;
        c.angle = [present_langle, present_langle + angle / 2];
        if (equal_length) {
          length = length_scale;
        } else {
          length = c.length * length_scale;
        }
        c.loc = move_along(n.loc, c.angle[1], length);
        present_langle = present_langle + angle;
      }
    }
    return tree;
  };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.equal_angle = equal_angle;

}).call(this);
